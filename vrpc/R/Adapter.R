try_print_plot <- function(object, gfx_file) {
  out <- try(print(object), silent = TRUE)
  if (inherits(out, "try-error") &&
      !grepl("invalid graphics state", attr(out, "condition")$message)) {
    stop(sprintf("Failed to print plot: %s", attr(out, "condition")$message))
  }
  if (!file.exists(gfx_file)) {
    stop("This call did not generate any plot.")
  }
}

extract_svg <- function(object) {
  gfx_file <- tempfile()
  svglite::svglite(
    file = gfx_file, width = 10, height = 8, pointsize = 12
  )
  try_print_plot(object, gfx_file)
  dev.off()
  buffer <- base64enc::base64encode(gfx_file)
  file.remove(gfx_file)
  return(buffer)
}

extract_graphics <- function(evaluation, args) {
  index <- vapply(evaluation, inherits, logical(1), "recordedplot")
  plots <- evaluation[index]
  if (length(plots) < 1) {
    return(NULL)
  }
  last_plot <- plots[[length(plots)]]
  return(extract_svg(last_plot))
}

save_description <- function(name) {
  fields <- data.frame(
    Package = name,
    Type = "Session",
    Version = "0.1.0",
    Author = "VRPC",
    Date = as.character(Sys.Date()),
    Description = "This file is automatically generated by VRPC.",
    stringsAsFactors = FALSE
  )
  write.dcf(fields, file = "DESCRIPTION")
}

attach_session <- function(session_id, session_dir) {
  session_env <- new.env(parent = globalenv())
  if (is.null(session_id)) {
    return(session_env)
  }
  filepath <- file.path(session_dir, ".RData")
  if (file.exists(filepath)) {
    load(filepath, envir = session_env)
    env2ns(session_id, session_env, lib = dirname(dirname(filepath)))
  }
  return(session_env)
}

env2ns <- function(name, env, lib) {
  env <- force(env)
  ns <- makeNamespace(name, lib = lib)
  exports <- getNamespaceInfo(ns, "exports")
  object_names <- ls(env, all.names = TRUE)
  lapply(object_names, function(x) {
    assign(x, get(x, env, inherits = FALSE), ns)
    assign(x, x, exports)
  })
}

makeNamespace <- function(name, version = NULL, lib = NULL) {
  impenv <- new.env(parent = .BaseNamespaceEnv, hash = TRUE)
  attr(impenv, "name") <- paste("imports", name, sep = ":")
  env <- new.env(parent = impenv, hash = TRUE)
  name <- as.character(as.name(name))
  version <- as.character(version)
  info <- new.env(hash = TRUE, parent = baseenv())
  assign(".__NAMESPACE__.", info, envir = env)
  assign("spec", c(name = name, version = version), envir = info)
  setNamespaceInfo(env, "exports", new.env(hash = TRUE, parent = baseenv()))
  dimpenv <- new.env(parent = baseenv(), hash = TRUE)
  attr(dimpenv, "name") <- paste("lazydata", name, sep = ":")
  setNamespaceInfo(env, "lazydata", dimpenv)
  setNamespaceInfo(env, "imports", list(base = TRUE))
  setNamespaceInfo(env, "path", normalizePath(file.path(lib, name), "/", TRUE))
  setNamespaceInfo(env, "dynlibs", NULL)
  setNamespaceInfo(env, "S3methods", matrix(NA_character_, 0L, 3L))
  assign(".__S3MethodsTable__.", new.env(hash = TRUE, parent = baseenv()), envir = env)
  eval(as.call(list(quote(.Internal), quote(registerNamespace(name, env)))))
  env
}

save_session <- function(res, session_id, session_env) {
  if (is.null(session_id)) {
    return(NULL)
  }
  save(
    file = ".RData",
    envir = session_env,
    list = ls(session_env, all.names = TRUE),
    compress = FALSE
  )
  saveRDS(res, file = ".REval", compress = FALSE)
  saveRDS(utils::sessionInfo(), file = ".RInfo", compress = FALSE)
  saveRDS(.libPaths(), file = ".Rlibs", compress = FALSE)
  save_description(session_id)
}


json_call <- function(object_name,
                      call_id = NULL,
                      string_args = NULL,
                      session_id = NULL,
                      session_dir = NULL) {
  error_object <- NULL

  # set working directory
  setwd(session_dir)

  # evaluation result access
  eval_var_name <- paste0("$", object_name)

  # handles the evaluation callback
  handler <- evaluate::new_output_handler(
    value = function(val, visible = FALSE) {
      if (is.null(error_object)) {
        assign(eval_var_name, val, session_env)
      }
      invisible()
    }, error = function(e) {
      error_object <<- e
    }
  )

  # create environment in which to evaluate the call
  session_env <- attach_session(session_id, session_dir)

  # correctly handle pure and namespaced calls
  call_obj <- NULL
  tmp <- strsplit(object_name, "::", fixed = TRUE)[[1]]
  if (length(tmp) == 2) { # with namespace
    call_obj <- as.call(list(as.name("::"), as.name(tmp[1]), as.name(tmp[2])))
  } else {
    call_obj <- list(as.name(tmp))
  }

  # prepare the input for evaluation
  if (!is.null(string_args)) {
    args <- jsonlite::fromJSON(string_args, simplifyVector = FALSE)
    if (as.logical(length(args))) {
      for (i in seq_len(length(args))) {
        arg <- args[[i]]
        if (typeof(arg) == "character" && substr(arg, 1, 1) == "$") {
          args[[i]] <- get(arg, session_env)
        }
      }
    }
    call_obj <- as.call(c(call_obj, args))
  }

  # EVALUATE!
  res <- evaluate::evaluate(
    call_obj,
    envir = session_env,
    output_handler = handler
  )

  # set working directory again (as the evaluation may have changed it)
  setwd(session_dir)

  # save session
  save_session(res, session_id, session_env)

  out <- ifelse(
    is.null(error_object),
    prepare_output(get(eval_var_name, session_env), extract_graphics(res)),
    prepare_error(error_object)
  )
  if (!is.null(call_id)) {
    on_execution_done(call_id, out)
  }
  return(out)
}

create_session_dir <- function(session_id) {
  tmp <- file.path(tempdir(), "vrpc")
  if (is.null(session_id)) {
    tmp <- tempfile("__static__", tmpdir = tmp)
  } else {
    tmp <- file.path(tmp, session_id)
  }
  if (!dir.exists(tmp)) dir.create(tmp, recursive = TRUE)
  return(tmp)
}

prepare_error <- function(err) {
  msg <- trimws(
    tail(strsplit(toString(err), ": ", fixed = TRUE)[[1]], n = 1)
  )
  # as exception handling in R is underdeveloped, we will place a marker here
  return(paste0("__err__", msg))
}

prepare_output <- function(val, gfx) {
  if (is.null(val) && !is.null(gfx)) {
    return(jsonlite::toJSON(gfx, auto_unbox = TRUE))
  }
  trial1 <- try(jsonlite::toJSON(val, auto_unbox = TRUE), silent = TRUE)
  if (inherits(trial1, "try-error")) {
    if (!is.null(gfx)) {
      return(gfx)
    }
    trial2 <- try(toString(val))
    return(
      ifelse(inherits(trial2, "try-error"), "__not_serializable__", trial2)
    )
  }
  return(trial1)
}

vrpc_call <- function(func_name,
                      string_args,
                      call_id = NULL,
                      instance_id = NULL) {
  # create session_dir
  session_dir <- create_session_dir(instance_id)

  # evaluate request in a detached fork
  job <- parallel::mcparallel(
    json_call(
      object_name = func_name,
      string_args = string_args,
      call_id = call_id,
      session_id = instance_id,
      session_dir = session_dir
    ),
    detached = !is.null(call_id)
  )
  return(
    ifelse(is.null(call_id), parallel::mccollect(job)[[1]], TRUE)
  )
}
