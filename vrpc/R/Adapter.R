vrpc_call <- function(func_name,
                      string_args,
                      call_id = NULL,
                      instance_id = NULL) {
  # create session_dir
  session_dir <- create_session_dir(instance_id)

  print(paste0("Session Directory: ", session_dir))

  # evaluate request in a detached fork
  job <- parallel::mcparallel(
    json_call(
      object_name = func_name,
      string_args = string_args,
      call_id = call_id,
      session_id = instance_id,
      session_dir = session_dir,
      session_env = parent.env(environment())
    ),
    detached = !is.null(call_id)
  )
  return(
    ifelse(is.null(call_id), parallel::mccollect(job)[[1]], TRUE)
  )
}

create_session_dir <- function(session_id) {
  tmp <- file.path(tempdir(), "vrpc")
  if (is.null(session_id)) {
    tmp <- tempfile("__static__", tmpdir = tmp)
  } else {
    tmp <- file.path(tmp, session_id)
  }
  if (!dir.exists(tmp)) dir.create(tmp, recursive = TRUE)
  return(tmp)
}

json_call <- function(object_name,
                      call_id = NULL,
                      string_args = NULL,
                      session_id = NULL,
                      session_dir = NULL,
                      session_env = NULL) {
  error_object <- NULL

  # set working directory
  setwd(session_dir)

  # create environment in which to evaluate the call
  eval_env <- attach_session(session_id, session_env)

  # evaluation result access
  eval_var_name <- paste0(".", object_name)

  # handles the evaluation callback
  handler <- evaluate::new_output_handler(
    value = function(val, visible = FALSE) {
      if (is.null(error_object)) {
        assign(eval_var_name, val, eval_env)
      }
      invisible()
    }, error = function(e) {
      error_object <<- e
    }
  )

  # correctly handle pure and namespaced calls
  call_obj <- NULL
  tmp <- strsplit(object_name, "::", fixed = TRUE)[[1]]
  if (length(tmp) == 2) { # with namespace
    call_obj <- as.call(list(as.name("::"), as.name(tmp[1]), as.name(tmp[2])))
  } else {
    call_obj <- list(as.name(tmp))
  }

  # prepare the input for evaluation
  if (!is.null(string_args)) {
    args <- jsonlite::fromJSON(string_args, simplifyVector = FALSE)
    if (as.logical(length(args))) {
      for (i in seq_len(length(args))) {
        arg <- args[[i]]
        if (typeof(arg) == "character" && substr(arg, 1, 1) == "$") {
          args[[i]] <- get(paste0(".", substring(arg, 2)), eval_env)
        }
      }
    }
    call_obj <- as.call(c(call_obj, args))
  }

  # EVALUATE!
  res <- evaluate::evaluate(
    call_obj,
    envir = eval_env,
    output_handler = handler
  )

  # set working directory again (as the evaluation may have changed it)
  setwd(session_dir)

  # save session
  save_session(res, session_id, eval_env)

  out <- ifelse(
    is.null(error_object),
    prepare_output(get(eval_var_name, eval_env), extract_graphics(res)),
    prepare_error(error_object)
  )
  if (!is.null(call_id)) {
    on_execution_done(call_id, out)
  }
  return(out)
}

attach_session <- function(session_id, session_env) {
  if (is.null(session_id)) {
    return(new.env())
  }
  if (file.exists(".RData")) {
    load(".RData", envir = globalenv())
  }
  return(globalenv())
}

save_session <- function(res, session_id, eval_env) {
  if (is.null(session_id)) {
    return(NULL)
  }
  save(
    file = ".RData",
    envir = eval_env,
    list = ls(eval_env, all.names = TRUE),
    compress = FALSE
  )
  saveRDS(res, file = ".REval", compress = FALSE)
  saveRDS(utils::sessionInfo(), file = ".RInfo", compress = FALSE)
  saveRDS(.libPaths(), file = ".Rlibs", compress = FALSE)
  save_description(session_id)
}

save_description <- function(name) {
  fields <- data.frame(
    Package = name,
    Type = "Session",
    Version = "0.1.0",
    Author = "VRPC",
    Date = as.character(Sys.Date()),
    Description = "This file is automatically generated by VRPC.",
    stringsAsFactors = FALSE
  )
  write.dcf(fields, file = "DESCRIPTION")
}

prepare_output <- function(val, gfx) {
  if (is.null(val) && !is.null(gfx)) {
    return(jsonlite::toJSON(gfx, auto_unbox = TRUE))
  }
  trial1 <- try(jsonlite::toJSON(val, auto_unbox = TRUE), silent = TRUE)
  if (inherits(trial1, "try-error")) {
    if (!is.null(gfx)) {
      return(gfx)
    }
    trial2 <- try(toString(val))
    return(
      ifelse(inherits(trial2, "try-error"), "__not_serializable__", trial2)
    )
  }
  return(trial1)
}

extract_graphics <- function(evaluation, args) {
  index <- vapply(evaluation, inherits, logical(1), "recordedplot")
  plots <- evaluation[index]
  if (length(plots) < 1) {
    return(NULL)
  }
  last_plot <- plots[[length(plots)]]
  return(extract_svg(last_plot))
}

extract_svg <- function(object) {
  gfx_file <- tempfile()
  svglite::svglite(
    file = gfx_file, width = 10, height = 8, pointsize = 12
  )
  try_print_plot(object, gfx_file)
  dev.off()
  buffer <- base64enc::base64encode(gfx_file)
  file.remove(gfx_file)
  return(buffer)
}

try_print_plot <- function(object, gfx_file) {
  out <- try(print(object), silent = TRUE)
  if (inherits(out, "try-error") &&
    !grepl("invalid graphics state", attr(out, "condition")$message)) {
    stop(sprintf("Failed to print plot: %s", attr(out, "condition")$message))
  }
  if (!file.exists(gfx_file)) {
    stop("This call did not generate any plot.")
  }
}

prepare_error <- function(err) {
  msg <- trimws(
    tail(strsplit(toString(err), ": ", fixed = TRUE)[[1]], n = 1)
  )
  # as exception handling in R is underdeveloped, we will place a marker here
  return(paste0("__err__", msg))
}
